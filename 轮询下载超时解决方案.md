# 轮询下载任务超时解决方案

## 问题分析

原有的轮询下载任务存在以下超时问题：

1. **固定超时设置**：使用固定的100秒超时，无法适应不同网络条件和任务复杂度
2. **缺乏心跳机制**：长时间下载过程中没有保活机制，容易被误判为超时
3. **轮询策略简单**：使用固定间隔轮询，效率低且容易超时
4. **缺乏熔断机制**：失败时无法快速切换策略或停止无效请求
5. **监控能力不足**：缺乏实时监控和预警机制

## 解决方案

### 1. 动态超时管理 (`timeout_manager.py`)

**特性：**
- 基于历史性能数据动态调整超时时间
- 熔断器模式，快速失败和自动恢复
- 心跳机制，防止长时间无响应
- 操作统计和性能分析

**使用方法：**
```python
from app.utils.timeout_manager import timeout_manager

# 执行带超时控制的操作
result = await timeout_manager.execute_with_timeout(
    "download_chapter",
    download_function,
    heartbeat_callback=lambda op_id: print(f"心跳: {op_id}")
)
```

### 2. 智能轮询策略 (`enhanced_polling_strategy.py`)

**特性：**
- 多种轮询策略：固定间隔、指数退避、自适应、智能轮询
- 基于进度自动调整轮询频率
- 抖动机制避免雷群效应
- 完整的统计和监控

**轮询策略说明：**

| 策略 | 适用场景 | 特点 |
|------|----------|------|
| 固定间隔 | 简单任务 | 固定时间间隔轮询 |
| 指数退避 | 不稳定网络 | 失败时间隔翻倍 |
| 自适应 | 一般任务 | 基于响应时间调整 |
| 智能轮询 | 复杂任务 | 基于进度和历史数据智能调整 |

**使用方法：**
```python
from app.utils.enhanced_polling_strategy import polling_manager, PollingConfig

# 配置智能轮询
config = PollingConfig(
    strategy=PollingStrategy.SMART_POLLING,
    base_interval=2.0,
    max_interval=30.0,
    min_interval=0.5,
    max_attempts=200
)

# 启动轮询任务
task_id = await polling_manager.start_polling_task(
    "download_task_123",
    check_function=lambda: get_progress(),
    completion_check=lambda result: result.status == "completed",
    config=config
)
```

### 3. 超时监控和告警 (`timeout_monitor.py`)

**特性：**
- 实时监控任务运行状态
- 多级告警机制（信息、警告、错误、严重）
- 心跳超时检测
- 告警冷却和限制机制
- 可配置的阈值和回调

**告警级别：**
- **信息 (INFO)**：正常状态更新
- **警告 (WARNING)**：运行时间较长或心跳超时
- **错误 (ERROR)**：运行时间严重超时
- **严重 (CRITICAL)**：任务可能已死锁

### 4. 增强的配置选项

在 `config.py` 中新增的配置项：

```python
# 增强超时设置
POLLING_BASE_TIMEOUT: float = 30.0      # 轮询基础超时（秒）
POLLING_MAX_TIMEOUT: float = 300.0      # 轮询最大超时（秒）
POLLING_MIN_TIMEOUT: float = 10.0       # 轮询最小超时（秒）
POLLING_HEARTBEAT_INTERVAL: float = 5.0 # 心跳间隔（秒）
POLLING_MAX_ATTEMPTS: int = 200         # 轮询最大尝试次数

# 熔断器设置
CIRCUIT_BREAKER_FAILURE_THRESHOLD: int = 5      # 熔断器失败阈值
CIRCUIT_BREAKER_RECOVERY_TIMEOUT: float = 60.0  # 熔断器恢复超时（秒）
```

## API 使用指南

### 1. 启动异步下载任务

```bash
POST /api/novels/download/start?url=小说URL&sourceId=2&format=txt
```

返回：
```json
{
  "code": 202,
  "message": "accepted",
  "data": {
    "task_id": "uuid-task-id"
  }
}
```

### 2. 普通轮询进度（支持心跳）

```bash
GET /api/novels/download/progress?task_id=uuid-task-id
```

返回：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "task_id": "uuid-task-id",
    "status": "running",
    "progress_percentage": 45.5,
    "completed_chapters": 91,
    "total_chapters": 200,
    "timeout_stats": {
      "success_rate": 98.5,
      "average_time": 2.3,
      "circuit_state": "closed"
    }
  }
}
```

### 3. 智能轮询进度（推荐）

```bash
GET /api/novels/download/progress/smart?task_id=uuid-task-id&timeout=120
```

**优势：**
- 自动调整轮询间隔
- 基于进度智能优化
- 减少无效请求
- 更快的响应时间

### 4. 超时监控统计

```bash
GET /api/novels/monitor/timeout
```

返回：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "monitor_stats": {
      "active_tasks": 3,
      "total_alerts": 5,
      "alerts_by_level": {
        "warning": 3,
        "error": 2,
        "critical": 0
      }
    },
    "recent_alerts": [
      {
        "task_id": "uuid-task-id",
        "alert_level": "warning",
        "message": "任务运行时间较长 (185.3s)",
        "timestamp": 1703123456.789
      }
    ]
  }
}
```

## 最佳实践

### 1. 客户端轮询建议

```javascript
// 使用智能轮询API（推荐）
async function smartPollProgress(taskId, maxWaitTime = 600) {
    try {
        const response = await fetch(
            `/api/novels/download/progress/smart?task_id=${taskId}&timeout=${maxWaitTime}`
        );
        return await response.json();
    } catch (error) {
        console.error('智能轮询失败:', error);
        // 降级到普通轮询
        return await fallbackPoll(taskId);
    }
}

// 降级轮询策略
async function fallbackPoll(taskId) {
    let attempts = 0;
    const maxAttempts = 300; // 最多5分钟
    
    while (attempts < maxAttempts) {
        try {
            const response = await fetch(`/api/novels/download/progress?task_id=${taskId}`);
            const data = await response.json();
            
            if (data.data.status === 'completed' || data.data.status === 'failed') {
                return data;
            }
            
            // 动态调整间隔
            const progress = data.data.progress_percentage;
            let interval = 2000; // 默认2秒
            
            if (progress < 10) {
                interval = 1000; // 开始阶段1秒
            } else if (progress > 90) {
                interval = 5000; // 接近完成5秒
            }
            
            await new Promise(resolve => setTimeout(resolve, interval));
            attempts++;
            
        } catch (error) {
            console.error('轮询出错:', error);
            await new Promise(resolve => setTimeout(resolve, 5000));
            attempts++;
        }
    }
    
    throw new Error('轮询超时');
}
```

### 2. 服务端集成示例

```python
from app.utils.timeout_manager import timeout_manager
from app.utils.enhanced_polling_strategy import polling_manager
from app.utils.timeout_monitor import timeout_monitor

async def download_with_enhanced_timeout(url, source_id, task_id):
    """使用增强超时管理的下载"""
    
    # 注册监控
    await timeout_monitor.register_task(task_id, "download_novel")
    
    try:
        # 使用超时管理器执行下载
        result = await timeout_manager.execute_with_timeout(
            f"download_{task_id}",
            actual_download_function,
            url, source_id,
            heartbeat_callback=lambda op_id: timeout_monitor.update_heartbeat(task_id)
        )
        return result
    finally:
        # 清理监控
        await timeout_monitor.unregister_task(task_id)
```

### 3. 配置调优建议

根据不同场景调整配置：

**快速网络环境：**
```python
POLLING_BASE_TIMEOUT = 15.0
POLLING_HEARTBEAT_INTERVAL = 3.0
CIRCUIT_BREAKER_FAILURE_THRESHOLD = 3
```

**慢速网络环境：**
```python
POLLING_BASE_TIMEOUT = 60.0
POLLING_MAX_TIMEOUT = 600.0
POLLING_HEARTBEAT_INTERVAL = 10.0
CIRCUIT_BREAKER_FAILURE_THRESHOLD = 8
```

**大型任务：**
```python
POLLING_MAX_ATTEMPTS = 500
POLLING_MAX_TIMEOUT = 1800.0  # 30分钟
```

## 监控和调试

### 1. 查看超时统计

```bash
curl "http://localhost:8000/api/novels/monitor/timeout"
```

### 2. 查看轮询统计

在智能轮询响应中包含 `polling_stats` 字段：

```json
{
  "polling_stats": {
    "task_name": "poll_uuid-task-id",
    "attempt_count": 45,
    "consecutive_failures": 0,
    "average_check_duration": 0.123,
    "total_elapsed_time": 90.5
  }
}
```

### 3. 日志监控

关键日志标识：
- `🚨 超时告警 [CRITICAL]`：严重超时
- `❌ 超时告警 [ERROR]`：错误超时
- `⚠️ 超时告警 [WARNING]`：警告超时
- `熔断器 xxx 进入开启状态`：熔断器触发

## 性能优化效果

实施此解决方案后，预期效果：

1. **超时率降低 70%**：通过动态调整和熔断机制
2. **响应时间提升 50%**：智能轮询减少无效请求
3. **系统稳定性提升**：心跳和监控机制及时发现问题
4. **用户体验改善**：更准确的进度反馈和预估时间

## 故障排除

### 常见问题和解决方案

1. **频繁超时告警**
   - 检查网络连接质量
   - 适当增加超时阈值
   - 检查服务器负载

2. **熔断器频繁触发**
   - 降低熔断阈值或增加恢复时间
   - 检查目标服务稳定性
   - 考虑使用备用书源

3. **轮询效率低**
   - 调整轮询策略为智能轮询
   - 优化轮询间隔配置
   - 减少并发轮询任务数量

4. **内存占用过高**
   - 定期清理完成的任务和告警
   - 限制监控任务数量
   - 调整统计窗口大小