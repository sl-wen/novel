# 异步下载API异常修复方案

## 问题诊断

通过测试发现，异步下载API存在以下异常问题：

### 1. 主要问题：任务状态不同步
- **现象**：使用无效URL或不存在的网站时，任务一直处于"running"状态
- **根本原因**：异常处理中的状态更新可能被中断或失败
- **影响**：导致客户端持续轮询，出现"连续查询失败"的错误

### 2. 测试验证结果

**测试案例1：无效URL**
```bash
curl -X POST "http://localhost:8000/api/novels/download/start?url=invalid_url&sourceId=999&format=txt"
# 结果：任务创建成功，但一直处于running状态，没有失败
```

**测试案例2：不存在的网站**
```bash
curl -X POST "http://localhost:8000/api/novels/download/start?url=https%3A//nonexistent-site.com/book/123&sourceId=1&format=txt"
# 结果：任务创建成功，但一直处于running状态，没有正确处理网络错误
```

## 修复方案

### 方案1：增强异常处理机制

在 `app/api/endpoints/novels.py` 的异步下载函数中添加更严格的异常捕获：

```python
@router.post("/download/start")
async def start_download(
    url: str = Query(..., description="小说详情页URL"),
    sourceId: int = Query(settings.DEFAULT_SOURCE_ID, description="书源ID"),
    format: str = Query(settings.DEFAULT_FORMAT, description="下载格式，支持txt、epub"),
):
    """启动异步下载任务，立即返回任务ID（增强版）"""
    try:
        from app.utils.progress_tracker import progress_tracker
        from app.utils.timeout_manager import timeout_manager
        from app.utils.timeout_monitor import timeout_monitor
        
        # 预验证URL和书源
        if not url or not url.startswith(('http://', 'https://')):
            return JSONResponse(
                status_code=400, 
                content={"code": 400, "message": "无效的URL格式", "data": None}
            )
        
        # 验证书源是否存在
        try:
            from app.models.source import Source
            source = Source(sourceId)
            if not source.rule.get('enabled', True):
                return JSONResponse(
                    status_code=400,
                    content={"code": 400, "message": f"书源 {sourceId} 已禁用", "data": None}
                )
        except Exception:
            return JSONResponse(
                status_code=400,
                content={"code": 400, "message": f"书源 {sourceId} 不存在", "data": None}
            )
        
        # 创建任务
        task_id = progress_tracker.create_task(total_chapters=0)
        progress_tracker.start_task(task_id)
        logger.info(f"启动增强下载任务: {task_id} ({url}, source={sourceId}, format={format})")
        
        async def run_enhanced_download():
            """运行增强版下载任务"""
            try:
                # 注册超时监控
                await timeout_monitor.register_task(
                    task_id, 
                    "download_novel",
                    expected_duration=1800.0,
                    custom_thresholds={
                        "warning": 600.0,
                        "error": 1800.0,
                        "critical": 3600.0,
                    }
                )
                
                # 使用超时管理器执行下载
                file_path = await timeout_manager.execute_with_timeout(
                    f"download_task_{task_id}",
                    novel_service.download,
                    url, sourceId, format, task_id,
                    heartbeat_callback=lambda op_id: (
                        progress_tracker.heartbeat(task_id),
                        timeout_monitor.update_heartbeat(task_id),
                        logger.debug(f"下载任务心跳: {task_id}")
                    )
                )
                
                if file_path:
                    progress_tracker.set_file_path(task_id, file_path)
                    progress_tracker.complete_task(task_id, True)
                    logger.info(f"下载任务完成: {task_id} -> {file_path}")
                else:
                    progress_tracker.complete_task(task_id, False, "文件生成失败")
                    logger.error(f"下载任务失败: {task_id} - 文件生成失败")
                    
            except asyncio.TimeoutError:
                error_msg = f"下载任务超时: {task_id}"
                logger.error(error_msg)
                try:
                    progress_tracker.complete_task(task_id, False, error_msg)
                except Exception as e:
                    logger.error(f"更新任务状态失败: {str(e)}")
                    
            except Exception as e:
                error_msg = f"后台下载任务失败: {str(e)}"
                logger.error(error_msg)
                try:
                    progress_tracker.complete_task(task_id, False, error_msg)
                except Exception as update_error:
                    logger.error(f"更新任务状态失败: {str(update_error)}")
                    
            finally:
                # 清理超时监控
                try:
                    await timeout_monitor.unregister_task(task_id)
                except Exception as e:
                    logger.warning(f"清理超时监控失败: {str(e)}")
                
                # 确保任务有最终状态
                try:
                    progress = progress_tracker.get_progress(task_id)
                    if progress and progress.status == TaskStatus.RUNNING:
                        logger.warning(f"发现运行中的任务未正确结束，强制设为失败: {task_id}")
                        progress_tracker.complete_task(task_id, False, "任务异常终止")
                except Exception as e:
                    logger.error(f"最终状态检查失败: {str(e)}")
        
        # 后台执行增强版下载
        import asyncio
        asyncio.create_task(run_enhanced_download())
        
        return {"code": 202, "message": "accepted", "data": {"task_id": task_id}}
        
    except Exception as e:
        logger.error(f"启动下载任务失败: {str(e)}")
        return JSONResponse(status_code=500, content={"code": 500, "message": str(e), "data": None})
```

### 方案2：添加任务超时自动清理

在 `app/utils/progress_tracker.py` 中添加自动清理机制：

```python
class ProgressTracker:
    def __init__(self):
        # ... 现有代码 ...
        self._auto_cleanup_interval = 300  # 5分钟检查一次
        self._max_running_time = 3600     # 1小时最大运行时间
        
    async def _timeout_monitor_loop(self):
        """超时监控循环"""
        while True:
            try:
                await self._check_timeouts()
                await self._cleanup_stuck_tasks()  # 新增：清理卡住的任务
                await asyncio.sleep(self._auto_cleanup_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"超时监控循环异常: {str(e)}")
                await asyncio.sleep(60)
    
    async def _cleanup_stuck_tasks(self):
        """清理卡住的任务"""
        current_time = time.time()
        
        with self._lock:
            stuck_tasks = []
            for task_id, progress in self._tasks.items():
                # 检查运行中但超时的任务
                if (progress.status == TaskStatus.RUNNING and 
                    current_time - progress.start_time > self._max_running_time):
                    stuck_tasks.append(task_id)
            
            # 清理卡住的任务
            for task_id in stuck_tasks:
                logger.warning(f"发现卡住的任务，自动设为失败: {task_id}")
                self.complete_task(task_id, False, "任务超时自动清理")
```

### 方案3：客户端重试机制

**JavaScript客户端增强：**
```javascript
class NovelDownloadClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
        this.maxRetries = 3;
        this.retryDelay = 2000; // 2秒
    }
    
    async startDownload(url, sourceId = 2, format = 'txt') {
        const encodedUrl = encodeURIComponent(url);
        const apiUrl = `${this.baseUrl}/api/novels/download/start?url=${encodedUrl}&sourceId=${sourceId}&format=${format}`;
        
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                const response = await fetch(apiUrl, { method: 'POST' });
                const data = await response.json();
                
                if (data.code === 202) {
                    return data.data.task_id;
                } else {
                    throw new Error(data.message || '启动下载失败');
                }
            } catch (error) {
                console.error(`下载启动失败 (尝试 ${attempt}/${this.maxRetries}):`, error);
                
                if (attempt < this.maxRetries) {
                    await this.sleep(this.retryDelay * attempt);
                } else {
                    throw new Error(`连续 ${this.maxRetries} 次启动下载失败: ${error.message}`);
                }
            }
        }
    }
    
    async waitForCompletion(taskId, maxWaitTime = 600) {
        const startTime = Date.now();
        let consecutiveFailures = 0;
        const maxConsecutiveFailures = 5;
        
        while (Date.now() - startTime < maxWaitTime * 1000) {
            try {
                const progress = await this.getProgress(taskId);
                consecutiveFailures = 0; // 重置失败计数
                
                if (progress.status === 'completed') {
                    return { success: true, result: progress };
                } else if (progress.status === 'failed') {
                    return { 
                        success: false, 
                        error: progress.error_message || '下载失败' 
                    };
                }
                
                // 动态调整轮询间隔
                const interval = this.calculatePollingInterval(progress);
                await this.sleep(interval);
                
            } catch (error) {
                consecutiveFailures++;
                console.error(`获取进度失败 (${consecutiveFailures}/${maxConsecutiveFailures}):`, error);
                
                if (consecutiveFailures >= maxConsecutiveFailures) {
                    return { 
                        success: false, 
                        error: `连续 ${maxConsecutiveFailures} 次查询失败，请检查网络连接或稍后重试` 
                    };
                }
                
                await this.sleep(Math.min(this.retryDelay * consecutiveFailures, 10000));
            }
        }
        
        return { success: false, error: '下载超时' };
    }
    
    async getProgress(taskId) {
        const response = await fetch(`${this.baseUrl}/api/novels/download/progress?task_id=${taskId}`);
        const data = await response.json();
        
        if (data.code !== 200) {
            throw new Error(data.message || '获取进度失败');
        }
        
        return data.data;
    }
    
    calculatePollingInterval(progress) {
        // 基于进度动态调整轮询间隔
        if (progress.progress_percentage < 10) {
            return 1000; // 开始阶段1秒
        } else if (progress.progress_percentage > 90) {
            return 5000; // 接近完成5秒
        } else {
            return 2000; // 中间阶段2秒
        }
    }
    
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// 使用示例
const client = new NovelDownloadClient();

async function downloadNovel(url, sourceId = 2) {
    try {
        console.log('启动下载...');
        const taskId = await client.startDownload(url, sourceId);
        console.log('任务ID:', taskId);
        
        console.log('等待下载完成...');
        const result = await client.waitForCompletion(taskId);
        
        if (result.success) {
            console.log('下载完成:', result.result);
            return result.result;
        } else {
            console.error('下载失败:', result.error);
            throw new Error(result.error);
        }
    } catch (error) {
        console.error('下载过程异常:', error);
        throw error;
    }
}
```

### 方案4：服务端状态监控增强

添加定期任务状态检查：

```python
# 在 app/utils/progress_tracker.py 中添加
async def periodic_health_check(self):
    """定期健康检查，清理异常任务"""
    while True:
        try:
            current_time = time.time()
            
            with self._lock:
                for task_id, progress in list(self._tasks.items()):
                    # 检查长时间运行且无进展的任务
                    if (progress.status == TaskStatus.RUNNING and 
                        current_time - progress.last_heartbeat > 300 and  # 5分钟无心跳
                        progress.progress_percentage == 0):  # 无进展
                        
                        logger.warning(f"发现疑似卡住的任务: {task_id}")
                        self.complete_task(task_id, False, "任务长时间无响应，自动标记为失败")
            
            await asyncio.sleep(60)  # 每分钟检查一次
            
        except Exception as e:
            logger.error(f"健康检查异常: {str(e)}")
            await asyncio.sleep(60)
```

### 方案5：客户端智能重试策略

**Python客户端示例：**
```python
import asyncio
import aiohttp
import time
from typing import Optional, Dict, Any

class AsyncDownloadClient:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
        self.max_retries = 3
        self.max_poll_failures = 10
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def start_download(self, url: str, source_id: int = 2, format: str = 'txt') -> str:
        """启动异步下载任务"""
        import urllib.parse
        encoded_url = urllib.parse.quote(url)
        
        for attempt in range(1, self.max_retries + 1):
            try:
                async with self.session.post(
                    f"{self.base_url}/api/novels/download/start",
                    params={"url": url, "sourceId": source_id, "format": format}
                ) as response:
                    data = await response.json()
                    
                    if data.get("code") == 202:
                        task_id = data["data"]["task_id"]
                        print(f"下载任务已启动: {task_id}")
                        return task_id
                    else:
                        raise Exception(data.get("message", "启动下载失败"))
                        
            except Exception as e:
                print(f"启动下载失败 (尝试 {attempt}/{self.max_retries}): {str(e)}")
                if attempt < self.max_retries:
                    await asyncio.sleep(2 * attempt)
                else:
                    raise Exception(f"连续 {self.max_retries} 次启动失败: {str(e)}")
    
    async def wait_for_completion(self, task_id: str, max_wait_time: int = 1800) -> Dict[str, Any]:
        """等待下载完成"""
        start_time = time.time()
        consecutive_failures = 0
        
        while time.time() - start_time < max_wait_time:
            try:
                # 获取进度
                async with self.session.get(
                    f"{self.base_url}/api/novels/download/progress",
                    params={"task_id": task_id}
                ) as response:
                    data = await response.json()
                    
                    if data.get("code") != 200:
                        raise Exception(data.get("message", "获取进度失败"))
                    
                    progress = data["data"]
                    consecutive_failures = 0  # 重置失败计数
                    
                    print(f"进度: {progress['progress_percentage']:.1f}% "
                          f"({progress['completed_chapters']}/{progress['total_chapters']})")
                    
                    if progress["status"] == "completed":
                        return {"success": True, "result": progress}
                    elif progress["status"] == "failed":
                        return {
                            "success": False, 
                            "error": progress.get("error_message", "下载失败")
                        }
                    
                    # 动态调整轮询间隔
                    interval = self._calculate_poll_interval(progress)
                    await asyncio.sleep(interval)
                    
            except Exception as e:
                consecutive_failures += 1
                print(f"查询进度失败 ({consecutive_failures}/{self.max_poll_failures}): {str(e)}")
                
                if consecutive_failures >= self.max_poll_failures:
                    return {
                        "success": False,
                        "error": f"连续 {self.max_poll_failures} 次查询失败，请检查网络连接或稍后重试"
                    }
                
                # 指数退避
                await asyncio.sleep(min(2 ** consecutive_failures, 30))
        
        return {"success": False, "error": "下载超时"}
    
    def _calculate_poll_interval(self, progress: Dict[str, Any]) -> float:
        """计算轮询间隔"""
        percentage = progress.get("progress_percentage", 0)
        
        if percentage < 5:
            return 1.0  # 开始阶段频繁检查
        elif percentage > 95:
            return 3.0  # 接近完成时稍微频繁
        else:
            return 2.0  # 正常进行中

# 使用示例
async def download_novel_example():
    async with AsyncDownloadClient() as client:
        try:
            # 启动下载
            task_id = await client.start_download(
                "https://www.0xs.net/txt/1.html", 
                source_id=11, 
                format="txt"
            )
            
            # 等待完成
            result = await client.wait_for_completion(task_id)
            
            if result["success"]:
                print("下载完成:", result["result"]["file_path"])
            else:
                print("下载失败:", result["error"])
                
        except Exception as e:
            print("下载异常:", str(e))

# 运行示例
# asyncio.run(download_novel_example())
```

## 立即可用的解决方案

### 1. 检查任务状态
```bash
# 检查所有任务状态
curl "http://localhost:8000/api/novels/debug/tasks"

# 检查特定任务详情
curl "http://localhost:8000/api/novels/debug/task?task_id=YOUR_TASK_ID"
```

### 2. 清理异常任务
```bash
# 恢复异常任务状态
curl -X POST "http://localhost:8000/api/novels/debug/recover"
```

### 3. 正确的API调用方式
```bash
# 1. 启动下载（确保URL编码）
curl -X POST "http://localhost:8000/api/novels/download/start" \
  --data-urlencode "url=https://www.0xs.net/txt/1.html" \
  --data-urlencode "sourceId=11" \
  --data-urlencode "format=txt"

# 2. 使用智能轮询（推荐）
curl "http://localhost:8000/api/novels/download/progress/smart?task_id=TASK_ID&timeout=300"

# 3. 如果智能轮询失败，使用普通轮询
curl "http://localhost:8000/api/novels/download/progress?task_id=TASK_ID"
```

### 4. 错误处理最佳实践

**前端处理：**
```javascript
async function robustDownload(url, sourceId = 2) {
    let taskId;
    
    try {
        // 1. 启动下载
        taskId = await startDownloadWithRetry(url, sourceId);
        
        // 2. 等待完成（带错误恢复）
        const result = await waitWithErrorRecovery(taskId);
        
        return result;
        
    } catch (error) {
        // 如果有taskId，尝试获取错误详情
        if (taskId) {
            try {
                const debug = await fetch(`/api/novels/debug/task?task_id=${taskId}`);
                const debugData = await debug.json();
                console.error('任务调试信息:', debugData);
            } catch (debugError) {
                console.error('获取调试信息失败:', debugError);
            }
        }
        
        throw new Error(`下载失败: ${error.message}`);
    }
}
```

## 监控和预防

### 1. 实时监控
```bash
# 监控服务健康状态
watch -n 5 'curl -s "http://localhost:8000/api/optimized/health" | jq .'

# 监控超时统计
curl "http://localhost:8000/api/novels/monitor/timeout"
```

### 2. 日志监控
```bash
# 监控关键错误
tail -f logs/app.log | grep -E "(异常|失败|超时|ERROR|Exception)"
```

通过实施以上修复方案，您的异步下载API异常问题应该得到彻底解决，不再出现"连续查询失败"的情况。